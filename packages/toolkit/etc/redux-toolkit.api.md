## API Report File for "@reduxjs/toolkit"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { Action } from 'redux';
import type { ActionCreator } from 'redux';
import type { AnyAction } from 'redux';
import type { CombinedState } from 'redux';
import { default as createNextState } from 'immer';
import { createSelector } from 'reselect';
import { current } from 'immer';
import type { Dispatch } from 'redux';
import { Draft } from 'immer';
import { freeze } from 'immer';
import { isDraft } from 'immer';
import type { Middleware } from 'redux';
import { original } from 'immer';
import { OutputParametricSelector } from 'reselect';
import { OutputSelector } from 'reselect';
import { ParametricSelector } from 'reselect';
import type { PreloadedState } from 'redux';
import type { Reducer } from 'redux';
import type { ReducersMapObject } from 'redux';
import { Selector } from 'reselect';
import type { Store } from 'redux';
import type { StoreEnhancer } from 'redux';
import { ThunkAction } from 'redux-thunk';
import { ThunkDispatch } from 'redux-thunk';
import type { ThunkMiddleware } from 'redux-thunk';

// @public
export interface ActionCreatorWithNonInferrablePayload<T extends string = string> extends BaseActionCreator<unknown, T> {
    <PT extends unknown>(payload: PT): PayloadAction<PT, T>;
}

// @public
export interface ActionCreatorWithOptionalPayload<P, T extends string = string> extends BaseActionCreator<P, T> {
    (payload?: P): PayloadAction<P, T>;
}

// @public
export interface ActionCreatorWithoutPayload<T extends string = string> extends BaseActionCreator<undefined, T> {
    (): PayloadAction<undefined, T>;
}

// @public
export interface ActionCreatorWithPayload<P, T extends string = string> extends BaseActionCreator<P, T> {
    (payload: P): PayloadAction<P, T>;
}

// @public
export interface ActionCreatorWithPreparedPayload<Args extends unknown[], P, T extends string = string, E = never, M = never> extends BaseActionCreator<P, T, M, E> {
    (...args: Args): PayloadAction<P, T, M, E>;
}

// @public (undocumented)
export type ActionMatchingAllOf<Matchers extends [Matcher<any>, ...Matcher<any>[]]> = UnionToIntersection<ActionMatchingAnyOf<Matchers>>;

// @public (undocumented)
export type ActionMatchingAnyOf<Matchers extends [Matcher<any>, ...Matcher<any>[]]> = ActionFromMatcher<Matchers[number]>;

// @public
export interface ActionReducerMapBuilder<State> {
    addCase<ActionCreator extends TypedActionCreator<string>>(actionCreator: ActionCreator, reducer: CaseReducer<State, ReturnType<ActionCreator>>): ActionReducerMapBuilder<State>;
    addCase<Type extends string, A extends Action<Type>>(type: Type, reducer: CaseReducer<State, A>): ActionReducerMapBuilder<State>;
    addDefaultCase(reducer: CaseReducer<State, AnyAction>): {};
    addMatcher<A extends AnyAction>(matcher: ActionMatcher<A> | ((action: AnyAction) => boolean), reducer: CaseReducer<State, A>): Omit<ActionReducerMapBuilder<State>, 'addCase'>;
}

// @public @deprecated
export type Actions<T extends keyof any = string> = Record<T, Action>;

// @public
export type AsyncThunk<Returned, ThunkArg, ThunkApiConfig extends AsyncThunkConfig> = AsyncThunkActionCreator<Returned, ThunkArg, ThunkApiConfig> & {
    pending: AsyncThunkPendingActionCreator<ThunkArg, ThunkApiConfig>;
    rejected: AsyncThunkRejectedActionCreator<ThunkArg, ThunkApiConfig>;
    fulfilled: AsyncThunkFulfilledActionCreator<Returned, ThunkArg, ThunkApiConfig>;
    typePrefix: string;
};

// @public
export type AsyncThunkAction<Returned, ThunkArg, ThunkApiConfig extends AsyncThunkConfig> = (dispatch: GetDispatch<ThunkApiConfig>, getState: () => GetState<ThunkApiConfig>, extra: GetExtra<ThunkApiConfig>) => Promise<ReturnType<AsyncThunkFulfilledActionCreator<Returned, ThunkArg>> | ReturnType<AsyncThunkRejectedActionCreator<ThunkArg, ThunkApiConfig>>> & {
    abort(reason?: string): void;
    requestId: string;
    arg: ThunkArg;
    unwrap(): Promise<Returned>;
};

// @public
export type AsyncThunkOptions<ThunkArg = void, ThunkApiConfig extends AsyncThunkConfig = {}> = {
    condition?(arg: ThunkArg, api: Pick<GetThunkAPI<ThunkApiConfig>, 'getState' | 'extra'>): boolean | undefined;
    dispatchConditionRejection?: boolean;
    serializeError?: (x: unknown) => GetSerializedErrorType<ThunkApiConfig>;
    idGenerator?: () => string;
} & IsUnknown<GetPendingMeta<ThunkApiConfig>, {
    getPendingMeta?(base: {
        arg: ThunkArg;
        requestId: string;
    }, api: Pick<GetThunkAPI<ThunkApiConfig>, 'getState' | 'extra'>): GetPendingMeta<ThunkApiConfig>;
}, {
    getPendingMeta(base: {
        arg: ThunkArg;
        requestId: string;
    }, api: Pick<GetThunkAPI<ThunkApiConfig>, 'getState' | 'extra'>): GetPendingMeta<ThunkApiConfig>;
}>;

// @public
export type AsyncThunkPayloadCreator<Returned, ThunkArg = void, ThunkApiConfig extends AsyncThunkConfig = {}> = (arg: ThunkArg, thunkAPI: GetThunkAPI<ThunkApiConfig>) => AsyncThunkPayloadCreatorReturnValue<Returned, ThunkApiConfig>;

// @public
export type AsyncThunkPayloadCreatorReturnValue<Returned, ThunkApiConfig extends AsyncThunkConfig> = MaybePromise<IsUnknown<GetFulfilledMeta<ThunkApiConfig>, Returned, FulfillWithMeta<Returned, GetFulfilledMeta<ThunkApiConfig>>> | RejectWithValue<GetRejectValue<ThunkApiConfig>, GetRejectedMeta<ThunkApiConfig>>>;

// @public
export type CaseReducer<S = any, A extends Action = AnyAction> = (state: Draft<S>, action: A) => S | void | Draft<S>;

// @public
export type CaseReducerActions<CaseReducers extends SliceCaseReducers<any>> = {
    [Type in keyof CaseReducers]: CaseReducers[Type] extends {
        prepare: any;
    } ? ActionCreatorForCaseReducerWithPrepare<CaseReducers[Type]> : ActionCreatorForCaseReducer<CaseReducers[Type]>;
};

// @public @deprecated
export type CaseReducers<S, AS extends Actions> = {
    [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void;
};

// @public
export type CaseReducerWithPrepare<State, Action extends PayloadAction> = {
    reducer: CaseReducer<State, Action>;
    prepare: PrepareAction<Action['payload']>;
};

// @public (undocumented)
export type Comparer<T> = (a: T, b: T) => number;

// @public
export type ConfigureEnhancersCallback = (defaultEnhancers: readonly StoreEnhancer[]) => StoreEnhancer[];

// @public
export function configureStore<S = any, A extends Action = AnyAction, M extends Middlewares<S> = [ThunkMiddlewareFor<S>]>(options: ConfigureStoreOptions<S, A, M>): EnhancedStore<S, A, M>;

// @public
export interface ConfigureStoreOptions<S = any, A extends Action = AnyAction, M extends Middlewares<S> = Middlewares<S>> {
    devTools?: boolean | EnhancerOptions;
    enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback;
    middleware?: ((getDefaultMiddleware: CurriedGetDefaultMiddleware<S>) => M) | M;
    preloadedState?: PreloadedState<CombinedState<NoInfer<S>>>;
    reducer: Reducer<S, A> | ReducersMapObject<S, A>;
}

// @public
export function createAction<P = void, T extends string = string>(type: T): PayloadActionCreator<P, T>;

// @public
export function createAction<PA extends PrepareAction<any>, T extends string = string>(type: T, prepareAction: PA): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>;

// @public (undocumented)
export function createAsyncThunk<Returned, ThunkArg = void, ThunkApiConfig extends AsyncThunkConfig = {}>(typePrefix: string, payloadCreator: AsyncThunkPayloadCreator<Returned, ThunkArg, ThunkApiConfig>, options?: AsyncThunkOptions<ThunkArg, ThunkApiConfig>): AsyncThunk<Returned, ThunkArg, ThunkApiConfig>;

// @public
export const createDraftSafeSelector: typeof createSelector;

// @public (undocumented)
export function createEntityAdapter<T>(options?: {
    selectId?: IdSelector<T>;
    sortComparer?: false | Comparer<T>;
}): EntityAdapter<T>;

// @public
export function createImmutableStateInvariantMiddleware(options?: ImmutableStateInvariantMiddlewareOptions): Middleware;

export { createNextState }

// @public
export function createReducer<S>(initialState: S, builderCallback: (builder: ActionReducerMapBuilder<S>) => void): Reducer<S>;

// @public
export function createReducer<S, CR extends CaseReducers<S, any> = CaseReducers<S, any>>(initialState: S, actionsMap: CR, actionMatchers?: ActionMatcherDescriptionCollection<S>, defaultCaseReducer?: CaseReducer<S>): Reducer<S>;

export { createSelector }

// @public
export function createSerializableStateInvariantMiddleware(options?: SerializableStateInvariantMiddlewareOptions): Middleware;

// @public
export function createSlice<State, CaseReducers extends SliceCaseReducers<State>, Name extends string = string>(options: CreateSliceOptions<State, CaseReducers, Name>): Slice<State, CaseReducers, Name>;

// @public
export interface CreateSliceOptions<State = any, CR extends SliceCaseReducers<State> = SliceCaseReducers<State>, Name extends string = string> {
    extraReducers?: CaseReducers<NoInfer<State>, any> | ((builder: ActionReducerMapBuilder<NoInfer<State>>) => void);
    initialState: State;
    name: Name;
    reducers: ValidateSliceCaseReducers<State, CR>;
}

export { current }

// @public (undocumented)
export interface Dictionary<T> extends DictionaryNum<T> {
    // (undocumented)
    [id: string]: T | undefined;
}

export { Draft }

// @public
export interface EnhancedStore<S = any, A extends Action = AnyAction, M extends Middlewares<S> = Middlewares<S>> extends Store<S, A> {
    dispatch: DispatchForMiddlewares<M> & Dispatch<A>;
}

// @public (undocumented)
export interface EntityAdapter<T> extends EntityStateAdapter<T> {
    // (undocumented)
    getInitialState(): EntityState<T>;
    // (undocumented)
    getInitialState<S extends object>(state: S): EntityState<T> & S;
    // (undocumented)
    getSelectors(): EntitySelectors<T, EntityState<T>>;
    // (undocumented)
    getSelectors<V>(selectState: (state: V) => EntityState<T>): EntitySelectors<T, V>;
    // (undocumented)
    selectId: IdSelector<T>;
    // (undocumented)
    sortComparer: false | Comparer<T>;
}

// @public (undocumented)
export type EntityId = number | string;

// @public (undocumented)
export interface EntitySelectors<T, V> {
    // (undocumented)
    selectAll: (state: V) => T[];
    // (undocumented)
    selectById: (state: V, id: EntityId) => T | undefined;
    // (undocumented)
    selectEntities: (state: V) => Dictionary<T>;
    // (undocumented)
    selectIds: (state: V) => EntityId[];
    // (undocumented)
    selectTotal: (state: V) => number;
}

// @public (undocumented)
export interface EntityState<T> {
    // (undocumented)
    entities: Dictionary<T>;
    // (undocumented)
    ids: EntityId[];
}

// @public (undocumented)
export interface EntityStateAdapter<T> {
    // (undocumented)
    addMany<S extends EntityState<T>>(state: PreventAny<S, T>, entities: readonly T[] | Record<EntityId, T>): S;
    // (undocumented)
    addMany<S extends EntityState<T>>(state: PreventAny<S, T>, entities: PayloadAction<readonly T[] | Record<EntityId, T>>): S;
    // (undocumented)
    addOne<S extends EntityState<T>>(state: PreventAny<S, T>, entity: T): S;
    // (undocumented)
    addOne<S extends EntityState<T>>(state: PreventAny<S, T>, action: PayloadAction<T>): S;
    // (undocumented)
    removeAll<S extends EntityState<T>>(state: PreventAny<S, T>): S;
    // (undocumented)
    removeMany<S extends EntityState<T>>(state: PreventAny<S, T>, keys: readonly EntityId[]): S;
    // (undocumented)
    removeMany<S extends EntityState<T>>(state: PreventAny<S, T>, keys: PayloadAction<readonly EntityId[]>): S;
    // (undocumented)
    removeOne<S extends EntityState<T>>(state: PreventAny<S, T>, key: EntityId): S;
    // (undocumented)
    removeOne<S extends EntityState<T>>(state: PreventAny<S, T>, key: PayloadAction<EntityId>): S;
    // (undocumented)
    setAll<S extends EntityState<T>>(state: PreventAny<S, T>, entities: readonly T[] | Record<EntityId, T>): S;
    // (undocumented)
    setAll<S extends EntityState<T>>(state: PreventAny<S, T>, entities: PayloadAction<readonly T[] | Record<EntityId, T>>): S;
    // (undocumented)
    setMany<S extends EntityState<T>>(state: PreventAny<S, T>, entities: readonly T[] | Record<EntityId, T>): S;
    // (undocumented)
    setMany<S extends EntityState<T>>(state: PreventAny<S, T>, entities: PayloadAction<readonly T[] | Record<EntityId, T>>): S;
    // (undocumented)
    setOne<S extends EntityState<T>>(state: PreventAny<S, T>, entity: T): S;
    // (undocumented)
    setOne<S extends EntityState<T>>(state: PreventAny<S, T>, action: PayloadAction<T>): S;
    // (undocumented)
    updateMany<S extends EntityState<T>>(state: PreventAny<S, T>, updates: ReadonlyArray<Update<T>>): S;
    // (undocumented)
    updateMany<S extends EntityState<T>>(state: PreventAny<S, T>, updates: PayloadAction<ReadonlyArray<Update<T>>>): S;
    // (undocumented)
    updateOne<S extends EntityState<T>>(state: PreventAny<S, T>, update: Update<T>): S;
    // (undocumented)
    updateOne<S extends EntityState<T>>(state: PreventAny<S, T>, update: PayloadAction<Update<T>>): S;
    // (undocumented)
    upsertMany<S extends EntityState<T>>(state: PreventAny<S, T>, entities: readonly T[] | Record<EntityId, T>): S;
    // (undocumented)
    upsertMany<S extends EntityState<T>>(state: PreventAny<S, T>, entities: PayloadAction<readonly T[] | Record<EntityId, T>>): S;
    // (undocumented)
    upsertOne<S extends EntityState<T>>(state: PreventAny<S, T>, entity: T): S;
    // (undocumented)
    upsertOne<S extends EntityState<T>>(state: PreventAny<S, T>, entity: PayloadAction<T>): S;
}

// @public (undocumented)
export function findNonSerializableValue(value: unknown, path?: string, isSerializable?: (value: unknown) => boolean, getEntries?: (value: unknown) => [string, any][], ignoredPaths?: readonly string[]): NonSerializableValue | false;

export { freeze }

// @public
export function getDefaultMiddleware<S = any, O extends Partial<GetDefaultMiddlewareOptions> = {
    thunk: true;
    immutableCheck: true;
    serializableCheck: true;
}>(options?: O): MiddlewareArray<Middleware<{}, S> | ThunkMiddlewareFor<S, O>>;

// @public
export function getType<T extends string>(actionCreator: PayloadActionCreator<any, T>): T;

// @public (undocumented)
export type IdSelector<T> = (model: T) => EntityId;

// @public
export interface ImmutableStateInvariantMiddlewareOptions {
    // (undocumented)
    ignore?: string[];
    ignoredPaths?: string[];
    isImmutable?: IsImmutableFunc;
    warnAfter?: number;
}

// @public
export function isAllOf<Matchers extends [Matcher<any>, ...Matcher<any>[]]>(...matchers: Matchers): (action: any) => action is UnionToIntersection<ActionFromMatcher<Matchers[number]>>;

// @public
export function isAnyOf<Matchers extends [Matcher<any>, ...Matcher<any>[]]>(...matchers: Matchers): (action: any) => action is ActionFromMatcher<Matchers[number]>;

// @public
export function isAsyncThunkAction(): (action: any) => action is UnknownAsyncThunkAction;

// @public
export function isAsyncThunkAction<AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]>(...asyncThunks: AsyncThunks): (action: any) => action is ActionsFromAsyncThunk<AsyncThunks[number]>;

// @public
export function isAsyncThunkAction(action: any): action is UnknownAsyncThunkAction;

export { isDraft }

// @public
export function isFulfilled(): (action: any) => action is UnknownAsyncThunkFulfilledAction;

// @public
export function isFulfilled<AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]>(...asyncThunks: AsyncThunks): (action: any) => action is FulfilledActionFromAsyncThunk<AsyncThunks[number]>;

// @public
export function isFulfilled(action: any): action is UnknownAsyncThunkFulfilledAction;

// @public
export function isImmutableDefault(value: unknown): boolean;

// @public
export function isPending(): (action: any) => action is UnknownAsyncThunkPendingAction;

// @public
export function isPending<AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]>(...asyncThunks: AsyncThunks): (action: any) => action is PendingActionFromAsyncThunk<AsyncThunks[number]>;

// @public
export function isPending(action: any): action is UnknownAsyncThunkPendingAction;

// @public
export function isPlain(val: any): boolean;

// @public
export function isPlainObject(value: unknown): value is object;

// @public
export function isRejected(): (action: any) => action is UnknownAsyncThunkRejectedAction;

// @public
export function isRejected<AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]>(...asyncThunks: AsyncThunks): (action: any) => action is RejectedActionFromAsyncThunk<AsyncThunks[number]>;

// @public
export function isRejected(action: any): action is UnknownAsyncThunkRejectedAction;

// @public
export function isRejectedWithValue(): (action: any) => action is UnknownAsyncThunkRejectedAction;

// @public
export function isRejectedWithValue<AsyncThunks extends [AnyAsyncThunk, ...AnyAsyncThunk[]]>(...asyncThunks: AsyncThunks): (action: any) => action is RejectedWithValueActionFromAsyncThunk<AsyncThunks[number]>;

// @public
export function isRejectedWithValue(action: any): action is UnknownAsyncThunkRejectedAction;

// @public (undocumented)
export class MiddlewareArray<Middlewares extends Middleware<any, any>> extends Array<Middlewares> {
    // (undocumented)
    static get [Symbol.species](): any;
    constructor(arrayLength?: number);
    constructor(...items: Middlewares[]);
    // (undocumented)
    concat<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(items: AdditionalMiddlewares): MiddlewareArray<Middlewares | AdditionalMiddlewares[number]>;
    // (undocumented)
    concat<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(...items: AdditionalMiddlewares): MiddlewareArray<Middlewares | AdditionalMiddlewares[number]>;
    // (undocumented)
    prepend<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(items: AdditionalMiddlewares): MiddlewareArray<AdditionalMiddlewares[number] | Middlewares>;
    // (undocumented)
    prepend<AdditionalMiddlewares extends ReadonlyArray<Middleware<any, any>>>(...items: AdditionalMiddlewares): MiddlewareArray<AdditionalMiddlewares[number] | Middlewares>;
}

// @public
export const miniSerializeError: (value: any) => SerializedError;

// @public (undocumented)
export let nanoid: (size?: number) => string;

export { original }

export { OutputParametricSelector }

export { OutputSelector }

export { ParametricSelector }

// @public
export type PayloadAction<P = void, T extends string = string, M = never, E = never> = {
    payload: P;
    type: T;
} & ([M] extends [never] ? {} : {
    meta: M;
}) & ([E] extends [never] ? {} : {
    error: E;
});

// @public
export type PayloadActionCreator<P = void, T extends string = string, PA extends PrepareAction<P> | void = void> = IfPrepareActionMethodProvided<PA, _ActionCreatorWithPreparedPayload<PA, T>, IsAny<P, ActionCreatorWithPayload<any, T>, IsUnknownOrNonInferrable<P, ActionCreatorWithNonInferrablePayload<T>, IfVoid<P, ActionCreatorWithoutPayload<T>, IfMaybeUndefined<P, ActionCreatorWithOptionalPayload<P, T>, ActionCreatorWithPayload<P, T>>>>>>;

// @public
export type PrepareAction<P> = ((...args: any[]) => {
    payload: P;
}) | ((...args: any[]) => {
    payload: P;
    meta: any;
}) | ((...args: any[]) => {
    payload: P;
    error: any;
}) | ((...args: any[]) => {
    payload: P;
    meta: any;
    error: any;
});

export { Selector }

// @public
export interface SerializableStateInvariantMiddlewareOptions {
    getEntries?: (value: any) => [string, any][];
    ignoredActionPaths?: string[];
    ignoredActions?: string[];
    ignoredPaths?: string[];
    ignoreState?: boolean;
    isSerializable?: (value: any) => boolean;
    warnAfter?: number;
}

// @public (undocumented)
export interface SerializedError {
    // (undocumented)
    code?: string;
    // (undocumented)
    message?: string;
    // (undocumented)
    name?: string;
    // (undocumented)
    stack?: string;
}

// @public
export interface Slice<State = any, CaseReducers extends SliceCaseReducers<State> = SliceCaseReducers<State>, Name extends string = string> {
    actions: CaseReducerActions<CaseReducers>;
    caseReducers: SliceDefinedCaseReducers<CaseReducers>;
    name: Name;
    reducer: Reducer<State>;
}

// @public @deprecated
export type SliceActionCreator<P> = PayloadActionCreator<P>;

// @public
export type SliceCaseReducers<State> = {
    [K: string]: CaseReducer<State, PayloadAction<any>> | CaseReducerWithPrepare<State, PayloadAction<any, string, any, any>>;
};

export { ThunkAction }

export { ThunkDispatch }

// @public (undocumented)
export function unwrapResult<R extends UnwrappableAction>(action: R): UnwrappedActionPayload<R>;

// @public (undocumented)
export type Update<T> = {
    id: EntityId;
    changes: Partial<T>;
};

// @public
export type ValidateSliceCaseReducers<S, ACR extends SliceCaseReducers<S>> = ACR & {
    [T in keyof ACR]: ACR[T] extends {
        reducer(s: S, action?: infer A): any;
    } ? {
        prepare(...a: never[]): Omit<A, 'type'>;
    } : {};
};


export * from "redux";

// (No @packageDocumentation comment for this package)

```
